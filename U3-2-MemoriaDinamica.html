<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Memoria Din치mica</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/league.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./_assets/slides/css/filminas.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Inform치tica II
<p>
    <small>Created by
        <a href="https://t.me/rmarku" target="_blank">
            <i class="fab fa-telegram-plane"></i>rmarku
        </a>
    </small>
</p>

</script></section><section  data-markdown><script type="text/template">
# Memoria Din치mica



</script></section><section  data-markdown><script type="text/template">
## Almacenamiento est치tico

La forma convencional de almacenar las variables en memoria se denomina est치tica.

Con este m칠todo, al inicio del programa le informamos cuanta memoria necesitamos

</script></section><section  data-markdown><script type="text/template">
## Almacenamiento est치tico
#### <span style="color: red"> Inconvenientes </span>
    
<span style="font-size: 0.7em">

* No puedo guardar mas datos de los que uso en c칩digo
* Para hacerlo gen칠rico reservo muchos mas datos de los que utilizo
* Solo implementable en tiempo de compilaci칩n

</span>

#### <span style="color: lightgreen"> Ventajas </span>
    
* No me preocupo por el manejo de memoria
    
</script></section><section  data-markdown><script type="text/template">
## Almacenamiento din치mico

En tiempo de ejecuci칩n, le digo al Sistema Operativo que me de mas memoria

Esto permite trabajar con cualquier tama침o de datos

</script></section><section  data-markdown><script type="text/template">
## Almacenamiento din치mico

#### Ventaja
    
* Puedo utilizar solo la memoria que me hace falta
* Puedo pedir mas memoria a demanda
    
#### Inconvenientes
    
* Debo asegurarme de liberar la memoria que ya no utilizo

</script></section><section  data-markdown><script type="text/template">
## Asignaci칩n din치mica de memoria
    
* Almacenamiento est치tico y din치mico
* Funciones <span style="color: red">malloc()</span> y <span style="color: red">free()</span> (C)
* Funciones <span style="color: lightgreen">new</span> y <span style="color: lightgreen">delete</span> (C++)
* Ejemplos de asignaci칩n de memoria para arreglos
* Ejemplos de asignaci칩n de memoria para matrices
    

</script></section><section  data-markdown><script type="text/template">
## <span style="color: red;">malloc</span>: Memory Allocation
Allocation = Asignaci칩n

Allocation != Alocar
 
Alocar = Causar locura
 
Luego, la memoria no se aloca 游뱕

La memoria se Asigna
</script></section><section  data-markdown><script type="text/template">
## <span style="color:red;">malloc</span>: Memory Allocation

### Sintaxis


```cpp
    void* malloc(cantBytes);
```

Se le piden <i>cantBytes</i> al Sistema Operativo. Este devuelve un puntero
a donde comienza dicha memoria o NULL si no hay memoria disponible
Nota: debo castear <span style="color: darkgrey;">**void**</span> al tipo de datos al que va a apuntar el puntero


</script></section><section  data-markdown><script type="text/template">
## <span style="color:red;">malloc</span>: Ejemplo

Creo un arreglo de 5 enteros de manera din치mica


```cpp
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = (int*)malloc( cant * sizeof(int));
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
}
```



</script></section><section  data-markdown><script type="text/template">

## <span style="color:red;">malloc</span>: Ejemplo

### 쯏 eso es todo?

No, debo verificar que malloc pudo reservarme esa memoria, de lo contrario me devuelve <span style="color: yellow;">NULL</span>


</script></section><section  data-markdown><script type="text/template">
## <span style="color:red;">malloc</span>: Ejemplo


```cpp
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = (int*)malloc( cant * sizeof(int));
    if(miPuntero == NULL){
        cout << "No tengo tanta memoria!";
        exit(EXIT_FAILURE);
    }
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
}
```


</script></section><section  data-markdown><script type="text/template">
## <span style="color:red;">malloc</span>: Ejemplo

### Bueno, ahora si eso es todo

No!, al no utilizar mas esos recursos, debo liberar esa memoria. Devolverle al sistema operativo lo que me prest칩.

![MemHog](images/memhog.webp)

</script></section><section  data-markdown><script type="text/template">
## <span style="color:red;">malloc</span>: Ejemplo completo


```cpp
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = (int*)malloc( cant * sizeof(int));
    if(miPuntero == NULL){
        cout << "No tengo tanta memoria!";
        exit(EXIT_FAILURE);
    }
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
    for( i = 0 ; i < cant ; i++ ){
        cout << "dato " << i << " = " <<  miPuntero[i];
    }
    free(miPuntero);
}
```


</script></section><section  data-markdown><script type="text/template">

## new/delete: Asignaci칩n de memoria en C++

En C++ se introducen las funciones new y delete, que vienen a remplazar a malloc() y free()

New tiene como ventaja que no hay que pasarle los valores en bytes, sino el tipo de dato que quiero.

En realidad, new y delete hacen mas cosas que malloc y free. Esto es debido que si hago un new de una clase
        (POO) new ejecuta el constructor de la clase.


</script></section><section  data-markdown><script type="text/template">
## new/delete: Ejemplo

```cpp
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = new int;
    if(miPuntero == nullptr){
        cout << "No tengo tanta memoria!";
        exit(EXIT_FAILURE);
    }
    cin >> *miPuntero;

    cout << "dato " << i << " = " <<  *miPuntero;

    delete miPuntero;
}
```



</script></section><section  data-markdown><script type="text/template">
## Matrices

Las matrices son arreglos de arreglos, pero mediante el uso de memoria din치mica, cada arreglo puede tener tama침o distinto.
Luego, es mas general que una matriz.
Debo pedir memoria para el arreglo de arreglos y para cada uno de esos arreglos


</script></section><section  data-markdown><script type="text/template">
## Matrices: Ejemplo

```cpp
#include &lt;iostream&gt;

int main(){
    int **miMatriz;
    int filas, columnas;
    cin >> filas;
    cin >> columnas;
    miMatriz = miMatriz = new int*[filas]; // o (int**) malloc( filas * sizeof(int*) );
    // Deber칤a vefiricar que miMatriz no es NULL
    int i;
    for( i = 0 ; i < filas ; i++ ){
        miMatriz[i] =  new int[columnas]; // o (int*) malloc( columnas * sizeof(int) );
        // Deber칤a vefiricar que miMatriz[i] no es NULL
    }
    // Lo mismo con el Free, debo liberar cada malloc que hice.
    for( i = 0 ; i < filas ; i++ ){
        delete[] miMatriz[i]; // o free(miMatriz[i]);
    }
    delete[] miMatriz; // o free(miMatriz);
}
```


</script></section><section  data-markdown><script type="text/template">
## malloc, calloc, realloc

Hay dos funciones mas que nos simplifican el uso de memoria con malloc

</script></section><section  data-markdown><script type="text/template">

### Calloc

Similar a Malloc, pero llena de 0 la memoria solicitada:

```cpp
    void* calloc(cant_elementos, tama침o);
```

</script></section><section  data-markdown><script type="text/template">
### Realloc

Aumenta el tama침o 
de memoria asignado anteriormente y copia el contenido inicial al nuevo.

```cpp
    void* realloc(puntero_anterior, tama침o);
```

</script></section><section  data-markdown><script type="text/template">

# To Code

![CodeMonkey](images/CodeMonkey2.webp)
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true}, queryOptions);
    </script>

    <script src="./_assets/slides/js/pruebas.js"></script>
    <script src="./_assets/slides/js/init.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
