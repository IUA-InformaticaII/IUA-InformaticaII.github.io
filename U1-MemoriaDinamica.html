<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Para comenzar</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />
    <link rel="stylesheet" href="./_assets/slides/css/filminas.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Informática II
<small>
<i class="fab fa-telegram"></i>
[rmarku]("https://t.me/rmarku")
</small>

</script></section><section  data-markdown><script type="text/template">
# Memoria Dinámica



</script></section><section  data-markdown><script type="text/template">
## Asignación dinámica de memoria
    
* Almacenamiento estático y dinámico
* Funciones malloc() y free() (C)
* Funciones new y delete (C++)
* Ejemplos de asignación de memoria para arreglos
* Ejemplos de asignación de memoria para matrices
    

</script></section><section  data-markdown><script type="text/template">
## Almacenamiento estático

La forma convencional de almacenar las variables en memoria se denomina estático.

Con este método, al inicio del programa le informamos cuanta memoria necesitamos

</script></section><section  data-markdown><script type="text/template">
## Almacenamiento estático
#### Inconvenientes
    
* No puedo utilizar mas datos de los que reserve en código
* Para hacerlo genérico reservo muchos mas datos de los que utilizo
* Solo implementable en tiempo de compilación
    
#### Ventaja
    
* No me preocupo por el manejo de memoria
    


</script></section><section  data-markdown><script type="text/template">
## Almacenamiento dinámico

En tiempo de ejecución, le digo al Sistema Operativo que me de mas memoria

Esto permite trabajar con cualquier tamaño de datos


</script></section><section  data-markdown><script type="text/template">
## Almacenamiento dinámico

#### Ventaja
    
* Puedo utilizar solo la memoria que me hace falta
* Puedo pedir mas memoria a demanda
    
#### Inconvenientes
    
* Debo asegurarme de liberar la memoria que ya no utilizo
    

</script></section><section  data-markdown><script type="text/template">
## malloc: Memory Allocation
Allocation = Asignación
Allocation != Alocar 
Alocar = Causar locura 
Luego, la memoria no se aloca

</script></section><section  data-markdown><script type="text/template">
## malloc: Memory Allocation

### Sintaxis
<pre><code class="hljs c++" data-trim>
    void* malloc(cantBytes);
</code></pre>
Se le piden <i>cantBytes</i> al Sistema Operativo. Este devuelve un puntero
a donde comienza dicha memoria o NULL si no hay memoria disponible
Nota: debo castear void al tipo de datos al que va a apuntar el puntero


</script></section><section  data-markdown><script type="text/template">
## malloc: Ejemplo

<pre><code class="hljs c++" data-trim>
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = (int*)malloc( cant * sizeof(int));
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
}
</code></pre>



</script></section><section  data-markdown><script type="text/template">

## malloc: Ejemplo

### ¿Y eso es todo?

No, debo verificar que malloc pudo reservarme esa memoria, de lo contrario me devuelve NULL


</script></section><section  data-markdown><script type="text/template">
## malloc: Ejemplo

<pre><code class="hljs c++" data-trim>
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = (int*)malloc( cant * sizeof(int));
    if(miPuntero == NULL){
        cout << "No tengo tanta memoria!";
        exit(EXIT_FAILURE);
    }
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
}
</code></pre>


</script></section><section  data-markdown><script type="text/template">
## malloc: Ejemplo

### Bueno, ahora si eso es todo

No!, al no utilizar mas esos recursos, debo liberar esa memoria. Devolverle al sistema operativo lo que me prestó.

<img src="images/memhog.jpg" alt="" style="height: 300px">

</script></section><section  data-markdown><script type="text/template">
## malloc: Ejemplo

<pre><code class="hljs c++" data-trim>
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = (int*)malloc( cant * sizeof(int));
    if(miPuntero == NULL){
        cout << "No tengo tanta memoria!";
        exit(EXIT_FAILURE);
    }
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
    for( i = 0 ; i < cant ; i++ ){
        cout << "dato " << i << " = " <<  miPuntero[i];
    }
    free(miPuntero);
}
</code></pre>


</script></section><section  data-markdown><script type="text/template">

## new/delete: Asignación de memoria en C++

En C++ se introducen las funciones new y delete, que vienen a remplazar a malloc() y free()
New tiene como ventaja que no hay que pasarle los valores en bytes, sino el tipo de dato que quiero.
    En realidad, new y delete hacen mas cosas que malloc y free. Esto es debido que si hago un new de una clase
        (POO) new ejecuta el constructor de la clase.


</script></section><section  data-markdown><script type="text/template">
## malloc: Ejemplo
<pre><code class="hljs c++" data-trim>
#include &lt;iostream&gt;

int main(){
    int *miPuntero;
    int cant = 5;
    cin >> cant;
    miPuntero = new int[cant];
    if(miPuntero == NULL){
        cout << "No tengo tanta memoria!";
        exit(EXIT_FAILURE);
    }
    int i;
    for( i = 0 ; i < cant ; i++ ){
        cin >> miPuntero[i];
    }
    for( i = 0 ; i < cant ; i++ ){
        cout << "dato " << i << " = " <<  miPuntero[i];
    }
    delete miPuntero;
}
</code></pre>



</script></section><section  data-markdown><script type="text/template">
## Matrices

Las matrices son arreglos de arreglos, pero mediante el uso de memoria dinamica, cada arreglo puede tener tamaño distinto.
Luego, es mas general que una matriz.
Debo pedir memoria para el arreglo de arreglos y para cada uno de esos arreglos


</script></section><section  data-markdown><script type="text/template">
## Matrices: Ejemplo

<pre><code class="hljs c++" data-trim>
#include &lt;iostream&gt;

int main(){
    int **miMatriz;
    int filas, columnas;
    cin >> filas;
    cin >> columnas;
    miMatriz = (int**) malloc( filas * sizeof(int*) );
    // Debería vefiricar que miMatriz no es NULL
    int i;
    for( i = 0 ; i < filas ; i++ ){
        miMatriz[i] = (int*) malloc( columnas * sizeof(int) );
        // Debería vefiricar que miMatriz[i] no es NULL
    }
    // Lo mismo con el Free, debo liberar cada malloc que hice.

    for( i = 0 ; i < filas ; i++ ){
        free(miMatriz[i]);
    }
    free(miMatriz);
}
</code></pre>


</script></section><section  data-markdown><script type="text/template">
## malloc, calloc, realloc

Hay dos funciones mas que nos simplifican el uso de memoria con malloc

### Calloc

Similar a Malloc, pero llena de 0 la memoria solicitada:

<pre><code class="hljs c++" data-trim>
    void* calloc(cant_elementos, tamaño);
</code></pre>
### Realloc
Aumenta el tamaño de memoria asignado anteriormente y copia el contenido inicial al nuevo.
<pre><code class="hljs c++" data-trim>
    void* realloc(puntero_anterior, tamaño);
</code></pre>

</script></section></div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true}, queryOptions);
    </script>

    <script src="./_assets/slides/js/pruebas.js"></script>
    <script src="./_assets/slides/js/init.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
